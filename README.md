# 2026GKD-Software-first-test

### 实时传感器流水线：继承与并发

#### 任务学习目标：

- 类的继承、(纯)虚函数`virtual`、重写`override`、覆盖
- 简单的多线程编程，认识什么是线程/进程，了解锁`mutex`和原子操作`atomic`，学习使用`std::thread`
- 了解回调函数的设计模式

假设你正在为一个简单的「实时传感器数据处理系统」编写核心组件。系统从多个传感器采集数据，需要经过一组有顺序的处理模块（滤波、放大、延迟缓冲等），最后输出到一个统一的告警通道，由主控程序读出后进行显示或上报。

这些处理模块的逻辑高度相似：都在后台独立运行，监视某个输入值，发现有新数据时做一段运算，再把结果写到下一个模块或最终输出。因此，本次任务要求你实现一个「任务管理类」，用于管理这条传感器数据处理流水线。

---

#### 任务目标：

实现一个「处理模块管理类」（可以类比为流水线），负责管理一类特定的「处理模块任务」。

被管理的「任务」（数据处理模块）具有以下抽象属性：

- 具有一个`int`类型的标识符`key`（例如传感器通道号或模块编号）
- 具有一个回调函数`void callback(int msg)`
- 具有一个运行函数`void run()`
- 具有一个停止函数`void stop()`
- 内部持有两个`int`类型指针`int *p_in, *p_out`
  - 持续监视`p_in`指向的变量，当`*p_in`不为`0`时，表示有新的「待处理采样值」
  - 对`*p_in`做相应的**运算**，并将其置零
  - 将运算结果写入`*p_out`（表示传给下游模块或最终输出）
  - 你不一定真的要存储`int *`，这里只是表示你需要操作两个指定地址的变量

「任务管理类」具有以下属性：

- 存在一个`int`类型的变量`out`，表示最终输出到主控程序的告警或处理结果
- 当任务管理类中有`n`个任务时，也对应存有`n`个`int`类型的变量`b_1, b_2, ..., b_n`，表示模块间的「中间缓冲区」：
  - 对于第`i`个任务来说，它应当监视`b_i`（对应上面的`p_in`），并操作`b_{i-1}`（对应上面的`p_out`）
  - 特别地，第`1`个任务应当监视`b_1`并将结果写入`out`变量（`p_out`指向`out`）
- 因此整个流水线结构类似：
  - 传感器或外部控制 → `b_n` → 第`n`个任务 → `b_{n-1}` → … → 第`1`个任务 → `out` → 主控程序

「任务管理类」需要具有以下功能：

- 线程1：监视变量`out`
  - 当`out`不为`0`时，表示有新的处理结果到达
  - 将`out`的值输出到标准输出（例如打印一行日志），然后将`out`置零
- 线程2：从标准输入`cin`接收控制指令，实现对流水线结构的动态管理：
  - 添加一个任务至末尾  
    命令格式：`add {key} {kind}`  
    其中`key`为任务标识符，`kind`为任务类型（见下文三种任务类型）。添加后任务应当自动进入运行状态（例如，你可以为该任务创建并启动一个线程，在线程中执行其`run`函数）。
  - 从末尾删除一个任务  
    命令格式：`pop`  
    删除当前流水线最末尾的任务，应当安全停止其线程、释放资源，并更新管理类中`b_i`的连接关系。
  - 触发一次回调  
    命令格式：`callback {key} {msg}`  
    查找标识符为`key`的任务，调用其`callback(int msg)`函数，传入`msg`作为参数，用于动态调整任务行为或注入新输入。

---

#### 任务类型设计（处理模块实例）

为贴近实际传感器场景，定义三种不同的处理模块类型，它们都继承自同一个抽象基类，例如`SensorTaskBase`：

1. TaskFilter（简单滤波任务）

   - 用于对传感器输入做基础滤波或偏移校正
   - 运算：将`(*p_in) + 1`的值写入`*p_out`，然后将`*p_in`置零
     - 可以理解为给采样值做一个简单的偏移校正
   - `callback(int msg)`：将`*p_in`的值修改为`msg`
     - 相当于通过外部控制直接注入一条新的原始采样值
   - 每次写入`*p_out`时，需要输出一行日志：  
     `write Filter-{key}: {val}`  
     其中`val`为写入的值

2. TaskGain（带放大系数的增益任务）

   - 内部含有一个比例系数`k`，初始为`1`
   - 运算：将`(*p_in) * k`的值写入`*p_out`，然后将`*p_in`置零
     - 可理解为对传感器信号做放大或缩小
   - `callback(int msg)`：
     - 将内部系数`k`修改为`msg`
     - 将`*p_in`修改为`1`（表示外部希望立即触发一次以新系数`k`为参数的测试或标定）
   - 每次写入`*p_out`时，需要输出：  
     `write Gain-{key}: {val}`

3. TaskDelayBuffer（带短延迟的缓冲任务）

   - 模拟处理链中的短暂缓冲或双阶段写入逻辑
   - 运算逻辑：
     1. 将`*p_in`的值暂存为`t`
     2. 将`*p_in`置零
     3. 将`t`写入`*p_out`
     4. 延迟`1ms`
     5. 将`t + 1`再次写入`*p_out`
   - `callback(int msg)`：将`*p_in`的值修改为`msg`，表示外部注入一个新的缓冲输入
   - 每次写入`*p_out`时都需要输出：  
     `write Delay-{key}: {val}`

注意：上述三种任务写入`*p_out`时必须遵循统一的输出格式，只是`{kind}`不同（Filter/Gain/Delay），用于方便测试和日志检查。

---

#### 注意

- 希望同学们自己充分测试后再提交，发现自己代码中的 bug 并修复，调试能力是代码能力中非常重要的一部分。
- 所有线程的主循环中建议加入约`1ms`的延迟，避免空转占用过高 CPU。
- 注意避免数据竞争，所有可能被多个线程同时读写的共享数据（包括`out`、`b_i`、任务列表等）都需要使用锁或原子变量保护。
- 当向任务列表添加、删除任务时，务必考虑与其他线程（任务运行线程、控制输入线程、输出监控线程）的并发访问问题。
- 子类和父类指针转换过程中要避免内存泄漏，基类应当提供虚析构函数。
- `stop`函数的存在是为了让任务线程有机会正常退出循环、回收资源。如果直接析构`std::thread`对象而没有先让线程结束，程序会异常终止。

---

#### 提示

- 可以设计一个抽象基类`SensorTaskBase`，统一定义`run`、`stop`、`callback`等接口，具体行为由`TaskFilter`、`TaskGain`、`TaskDelayBuffer`重写。思考为什么需要继承和虚函数？这种设计在实际工程中有什么好处？
- 如果使用`std::vector<int>`存储中间缓冲区`b_1, ..., b_n`，在执行`add`和`pop`操作时，指向缓冲区元素的指针是否可能失效？为什么？如何避免？
- 任务对象可以通过`std::unique_ptr<SensorTaskBase>`存储在`std::vector`中，配合虚析构函数避免内存泄漏。
- 当从末尾`pop`一个任务时，应先调用其`stop`函数，并等待对应线程安全结束，再释放该任务对象，最后更新缓冲区连接关系。
- 建议先从单线程版本（不真正启动任务线程，只手动调用一次运算逻辑）入手，确认功能正确后再逐步改造成多线程版本，以减少调试难度。
